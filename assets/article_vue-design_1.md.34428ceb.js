import{_ as s,o as n,c as a,a as l}from"./app.139652fc.js";const B=JSON.parse('{"title":"第一章 权衡的艺术","description":"","frontmatter":{},"headers":[{"level":2,"title":"1.1 命令式和声明式","slug":"_1-1-命令式和声明式","link":"#_1-1-命令式和声明式","children":[]},{"level":2,"title":"1.2 性能和可维护的权衡","slug":"_1-2-性能和可维护的权衡","link":"#_1-2-性能和可维护的权衡","children":[]},{"level":2,"title":"1.3 虚拟 DOM 的性能到底如何","slug":"_1-3-虚拟-dom-的性能到底如何","link":"#_1-3-虚拟-dom-的性能到底如何","children":[]},{"level":2,"title":"1.4 运行时和编译时","slug":"_1-4-运行时和编译时","link":"#_1-4-运行时和编译时","children":[]}],"relativePath":"article/vue-design/1.md"}'),p={name:"article/vue-design/1.md"},o=l(`<h1 id="第一章-权衡的艺术" tabindex="-1">第一章 权衡的艺术 <a class="header-anchor" href="#第一章-权衡的艺术" aria-hidden="true">#</a></h1><blockquote><p>框架的设计里到处都体现了权衡的艺术</p></blockquote><h2 id="_1-1-命令式和声明式" tabindex="-1">1.1 命令式和声明式 <a class="header-anchor" href="#_1-1-命令式和声明式" aria-hidden="true">#</a></h2><p>命令式主要的关注过程，比如下面命令</p><ul><li>获取一个 id 为 app 的元素</li><li>给它设置文本内容为 hello world</li><li>给它添加一个点击事件</li><li>点击之后弹出框提示：ok</li></ul><p>那么命令式的方式就是这样的：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> app </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">#app</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#BABED8;">app</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">innerHTML </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#BABED8;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">click</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">alert</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ok</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span>
<span class="line"></span></code></pre></div><blockquote><p>可以看到，声明式的每一步的代码执行，都和命令是一一对应的，代码本身描述的是：做事的过程</p></blockquote><p>那么声明式呢？与命令式完全不同，声明式更加关注结果</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">@click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">() =&gt; alert(&#39;ok&#39;)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">hello word</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>上面代码和命令式是一致的，只不过在 vue 内部已经为我们封装好了，你只要给 vue 下达一条，vue 就可以帮助我们完成效果。所以说 vue 的内部实现一定的<strong>命令式</strong>的。</p><h2 id="_1-2-性能和可维护的权衡" tabindex="-1">1.2 性能和可维护的权衡 <a class="header-anchor" href="#_1-2-性能和可维护的权衡" aria-hidden="true">#</a></h2><p>命令式和声明式的都有各自的优点，但是有一个结论是：<strong>声明式代码的性能不优于命令式代码的性能</strong>。</p><p>比如上述的例子中，我想将 div 中的文本内容修改为 <code>hello vue3</code>，那么就可以使用 <a href="https://tianyuhao.cn/blog/javascript/dom.html#textContent" target="_blank" rel="noreferrer">textContent</a> 方法直接进行修改</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#BABED8;">app</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">textContent </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello vue3</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span></code></pre></div><p>上面修改的方式就说性能最好的修改方式了，但是在命令式中，也行并不一定会做到这一点</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">&lt;!-- 之前 --&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">@click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">() =&gt; alert(&#39;ok&#39;)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">hello word</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">&lt;!-- 之后 --&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">@click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">() =&gt; alert(&#39;ok&#39;)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">hello vue3</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>对于框架来说，它需要先找出前后差异需要修改的地方，然后再进行修改，其实内部实现的代码依然是：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#BABED8;">app</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">textContent </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello vue3</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span></code></pre></div><p>假设我们将查找需要找出前后差异需要修改的地方需要消耗性能 A，修改内容需要消耗性能 B，那么结论就是：</p><ul><li>声明式需要消耗性能为：A + B</li><li>命令式需要消耗性能为：B</li></ul><p>可以发现，声明式多处了查找差异部分的性能消耗，但是如果将这部分的性能消耗降低到 0，那么声明式和命令式的性能消耗就是一样的了，但这显然是不可能的。所以得出前文的结论：<strong>声明式代码的性能不优于命令式代码的性能</strong>。</p><h2 id="_1-3-虚拟-dom-的性能到底如何" tabindex="-1">1.3 虚拟 DOM 的性能到底如何 <a class="header-anchor" href="#_1-3-虚拟-dom-的性能到底如何" aria-hidden="true">#</a></h2><p>目前我们先不用关注虚拟 DOM 具体是什么，前文说到：<code>声明式的性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗</code>，那么只要降低<code>找出差异的性能消耗</code>，才可以达到命令式一样的性能，虚拟 DOM，就是为了降低找出差异性能消耗这一步的。</p><p>对于原生操作，更多的建议是使用 <a href="https://tianyuhao.cn/blog/javascript/dom.html#document-createelement" target="_blank" rel="noreferrer">document.createElement()</a>，而不是 <a href="https://tianyuhao.cn/blog/javascript/dom.html#outerhtml-%E5%92%8C-innerhtml" target="_blank" rel="noreferrer">innerHTML</a>，因为 innerHTML 有着很多的劣势，比如：</p><ul><li>更新 DOM 需要整夜的更新，不能更新指定需要修改的内容</li><li>性能差</li><li>哪怕只是修改一个地方，也需要将旧的 DOM 全部销毁，再重新渲染一遍</li></ul><p>所以按照性能来说，<code>原生方法 document.createElement() &gt; 虚拟 DOM &gt; innerHTML</code></p><h2 id="_1-4-运行时和编译时" tabindex="-1">1.4 运行时和编译时 <a class="header-anchor" href="#_1-4-运行时和编译时" aria-hidden="true">#</a></h2><p>在设计框架的时候，有三种选择：<code>纯运行时、纯编译时、运行时+编译时</code>，接下来分别来解释一些这三种方式都是怎样的</p><p><strong>纯运行时</strong></p><p>假设我们有一个 render 函数，它接收一个树形结构的数据对像，可以将其递归渲染成 DOM 元素，对象如下</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">tag</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">children</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> [</span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">tag</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">span</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">children</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>上面对象中有两个属性，<code>tag</code> 代表是标签名，<code>children</code> 代表子节点，可以是一个数组或是一个字符串，如果是字符串那么就说节点的文本内容，如果是数组，就说节点在子元素。</p><p>接下来我们来实现 render 函数：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 渲染函数</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * </span><span style="color:#89DDFF;font-style:italic;">@</span><span style="color:#C792EA;font-style:italic;">param</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#89DDFF;font-style:italic;">{</span><span style="color:#FFCB6B;font-style:italic;"> object </span><span style="color:#89DDFF;font-style:italic;">}</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#BABED8;font-style:italic;">obj</span><span style="color:#676E95;font-style:italic;"> 数据对象</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * </span><span style="color:#89DDFF;font-style:italic;">@</span><span style="color:#C792EA;font-style:italic;">param</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#89DDFF;font-style:italic;">{</span><span style="color:#FFCB6B;font-style:italic;"> object </span><span style="color:#89DDFF;font-style:italic;">}</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#BABED8;font-style:italic;">node</span><span style="color:#676E95;font-style:italic;"> 放入的节点</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">render</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">node</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">el</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">tag</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">children</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">string</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">text</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createTextNode</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">children</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">el</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">text</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">children</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">children</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forEach</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">item</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">render</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">item</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">el</span><span style="color:#F07178;">))</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>这样就可以进行调用渲染函数来使用：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#82AAFF;">render</span><span style="color:#BABED8;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">body)</span></span>
<span class="line"></span></code></pre></div><p>但是这种方式的内部不涉及任何的其它处理，而且手写对象渲染太麻烦了，而且不支持 html 编写。所以，刚刚写的就说一个纯运行时的逻辑。</p><p>所以接下来我们可能就会想想：能不能把 HTML 标签编译成树形结构再继续使用 render 函数呢？</p><p><strong>运行时+编译时</strong></p><p>所以就编写了一个叫 <code>compiler</code> 的程序，它的作用是将 HTML 编译成树形结构的对象，这也就可以将 <code>compiler</code> 和 <code>render</code> 的函数结合起来了，<code>compiler</code> 内部具体的实现在这里暂时先不过多说明，目前已经超出了本章节方位，下面先暂且模拟效果进行演示</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> html </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#C3E88D;">  &lt;div&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">    &lt;span&gt;hello world&lt;/span&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">  &lt;/div&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">\`</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">compiler</span><span style="color:#BABED8;">(html)</span></span>
<span class="line"><span style="color:#82AAFF;">render</span><span style="color:#BABED8;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">body)</span></span>
<span class="line"></span></code></pre></div><p>首先将 HTML 编译成对象再通过 <code>render</code> 函数进行渲染，这就是一个<code>运行时 + 编译时</code>的逻辑</p><p><strong>编译时</strong></p><p>不过，这时可能又会有一个问题：可以将 HTML 字符串编译成对象，那么是不是可以将 HTML 字符串编译成命令式呢？这时就需要一个 <code>compiler</code> 函数了，连 <code>render</code> 函数都不需要了。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> div </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> span </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">span</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> text </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createTextNode</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#BABED8;">span</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#BABED8;">(text)</span></span>
<span class="line"><span style="color:#BABED8;">div</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#BABED8;">(span)</span></span>
<span class="line"><span style="color:#BABED8;">document</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">body</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#BABED8;">(div)</span></span>
<span class="line"></span></code></pre></div><p>上面演示得出结论：</p><ul><li>纯运行时的框架，由于它没用编译的过程，因此没用办法提供更多操作</li><li>纯运行时，是性能最好的，但是它缺少的灵活性</li><li>运行时 + 编译时，可以将两者部分的优点吸引进来，可以将分析哪些会改变，哪些不会改变，这样就可以使用 render 函数进行进一步优化，实现只更新需要修改的地方</li></ul>`,48),e=[o];function t(c,r,y,D,F,i){return n(),a("div",null,e)}const E=s(p,[["render",t]]);export{B as __pageData,E as default};
